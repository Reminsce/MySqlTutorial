
# MySqlTutorial
## 설치
윈도우 : [링크](http://itgroovy.tistory.com/793)  
centOS : [링크](https://zetawiki.com/wiki/CentOS_MySQL_%EC%84%A4%EC%B9%98)  

## SQL이란
SQL이란 Structured Query Language의 약자로, 구조화된 질의 언어라는 뜻이다. 처음 이 `구조화된 쿼리(질의) 언어`를 들으면 뭔 소린가 싶다. 사실 필자도 SQL이 대체 어느부분이 구조적이라는 건지는 잘 모르겠다. 다만 SQL이란.. 일반 프로그래밍 언어처럼 if else의 연속이 아니라 `SELECT * FROM DUAL;`과 같이 문장형 언어겠구나~ 싶은 감은 갖고 있다.  
어찌됐든 중요한건 SQL이란건 RDBMS를 효과적으로 만들고 조작하기 위해 만들어진 언어라는 것이다.  

## RDBMS란
RDBMS란 Relative Database Management System의 약자로, 관계형 데이터베이스를 의미한다. `관계`라는 단어가 처음에는 생소할 수 있다. 따라 유정하우스의 서열관계를 나타내는 DB를 예로 들어 설명하겠다.  

### 테이블
우선 유정하우스의 멤버는 이동규, 전유정, 남혜미, 김아정 총 4명이 있다. 이를 테이블로 표현해보겠다.  
  
`TBL_USERS`  

|NAME|
|----|
|이동규|
|전유정|
|남혜미|
|김아정|

  
`TBL_USERS`는 테이블 이름이다.  

### 서열관계 테이블
사실 서열관계는 1:N 관계가 아니라서 다음과 같이 표현할 수 있다.  

|NAME|RANK|
|----|----|
|이동규|1|
|전유정|2|
|남혜미|3|
|김아정|4|

  
유정하우스의 서열순위를 명확히 표현한 테이블이다.  
비슷한 방법으로 사용자에 대해 저장해야할 정보들이 더 있다면 얼마든지 추가할 수 있다.  

NAME|RANK|HOME
----|----|----
이동규|1|서울
전유정|2|논산
남혜미|3|인천
김아정|4|TK

  
하지만 다음과 같은 경우는 어떻게 할까?  
`유정하우스 멤버가 놀러갔던 장소들을 나타내는 테이블을 만들어보세요`  
  
그럼 갑자기 곤란해진다. 각 멤버가 놀러간 장소가 한두곳이 아니기 때문이다.  
우선 기존의 방식으로 표현하자면  

NAME|PLAYGROUND
----|----
이동규|건대,홍대
전유정|논산,딸기밭
남혜미|인천,국제공항
김아정|대구,뭐있냐;

  
이런식으로 만들 수 있겠다. 하지만 이는 좋은 방법이 아니다. SQL은 일반 프로그래밍 언어처럼 유연하지가 못해서 PLAYGROUND 열의 `건대,홍대` 중 건대만 없애봐! 라는 명령이 쉽지않다. (일반 자바프로그래밍에서도 이는 매우 귀찮은 작업이다. 문자열 '건대,홍대'에서 '건대'를 지우고 ',' 또한 지우는 예외처리는 상당히 귀찮다.)  
  
그래서 우리는 이와같은 구조를 1:N 구조라고 부른다. 동규라는 사람이 `1`명, 그 사람이 놀러간 곳은 `N`곳이기 때문이다. 그리고 관계형 테이블을 적극 활용한 테이블을 보여주겠다.  

`TBL_USERS`  

NAME|
----|
이동규|
전유정|
남혜미|
김아정|

  
`TBL_USER_PLAYGROUNDS`  

USER_NAME|PLAYGROUND
----|-------------|
이동규|건대
이동규|홍대
전유정|논산
전유정|딸기밭
남혜미|인천
남혜미|국제공항
김아정|대구
김아정|뭐있냐;

  
얼핏보면 이게 뭐지 싶을 수 있다. 하지만 이와 표현한 이유가 있다. 바로 `Foreign Key` 때문이다.  
가볍게 설명하자면 `TBL_USER_PLAYGROUNDS`라는 테이블의 `USER_NAME` 열은 `TBL_USER`의 `NAME`과 연결되어 있다. `Foreign Key`의 장점은 만약 유정하우스에서 누군가 탈퇴하게되어 `TBL_USER`의 한 column(열) 즉 이동규 column이 삭제되었을 때 연결된 `TBL_USER_PLAYGROUNDS`의 `USER_NAME`이 이동규인 row(행)는 모두 삭제된다. 이는 데이터 관리에 있어서 진짜진짜 편한 기능이다.  
  
하지만 저 테이블이 아직 완전한 형태는 아니다. 만약 유정하우스에 19학번 이동규도 가입했다고 치자. 그러면 `TBL_USERS` 테이블은 다음과 같이 바뀔 것이다.  

|NAME|
|----|
|이동규|
|전유정|
|남혜미|
|김아정|
|동규|

  
문제를 알겠는가? 이동규가 둘이다. 하나여도 극혐인데 둘이면 이는 매우 곤란하다.  
게다가 `TBL_USER_PLAYGROUNDS`는 더 가관이다.  

USER_NAME|PLAYGROUND
----|-------------|
이동규|건대
이동규|홍대
전유정|논산
전유정|딸기밭
남혜미|인천
남혜미|국제공항
김아정|대구
김아정|뭐있냐;
이동규|계룡
이동규|너무조와

  
대체 어떤 이동규가 건대, 홍대에서 노는 민간인인지, 어떤 이동규가 계룡에서 노는 군바리인지 구분할 수가 없다. 어쩌면 홍대, 계룡에서 노는 혼종일수도 있다. 이는 아무도 모른다.  
  
이와 같은 문제를 해결하기 위해서 SQL은 `Primary Key`를 지원한다. 우선 개선된 테이블을 먼저 보이겠다.  
`TBL_USERS`

ID|NAME|  
---|----|  
20162489|이동규|  
20161818|전유정|
20161234|남혜미|
20169876|김아정|
20190001|이동규|
  
눈치 빠른 사람이라면 이미 알겠지만 유니크한 `ID`가 추가됨으로써 동명이인도 구분할 수 있게 되었다. 바로 `ID` column이 `Primary Key`로 지정된 column 이다. 말 그대로 한 row를 대표하는 column인 것이다.  
덕분에 `TBL_USER_PLAYGROUNDS`도 다음과 같이 개선되었다.  

USER_NAME|PLAYGROUND
----|-------------|
20190001|건대
20190001|홍대
20161818|논산
20161818|딸기밭
20161234|인천
20161234|국제공항
20169876|대구
20169876|뭐있냐;
20162489|계룡
20162489|너무조와

  
이제야 군바리 이동규를 찾아낼 수 있게 되었다.  

## MySQL
SQL의 개념을 알게되었으니 이제 MySQL을 써보자  
우선 MySQL 명령어를 입력할 수 있는 터미널까지는 세팅이 되어 있을 것이다.  
아래 명령어를 차례로 입력하자
```
CREATE DATABASE TUTORIAL;
SHOW DATABASES;
```

그럼 방금 만든 TUTORIAL 데이터베이스가 보일 것이다.  
아래 명령어는 TUTORIAL 데이터베이스를 사용하겠다는 것이다.
```
USE TUTORIAL;
```

곧이어서 다음 명령어를 입력해보자
```
SHOW TABLES;
```

그럼 `Empty set`이 포함된 메세지가 뜰 것이다.  
당연하겠지만 테이블이 없다는 뜻이다.  
